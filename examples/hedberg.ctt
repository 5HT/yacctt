-- Hedbergs lemma: a type with decidable equality is a set
module hedberg where

import prelude

-- hedbergLemma' (A: U) (f : (a b : A) -> Path A a b -> Path A a b) (a :A) :
--   (b : A) (p : Path A a b) ->
--             Path (Path A a b) (compPath A a a b (f a a (refl A a)) p) (f a b p) =
--   J A a (\ (b:A) (p:Path A a b) -> Path (Path A a b) (compPath A a a b (f a a (refl A a)) p) (f a b p))
--     (refl (Path A a a) (f a a (refl A a)))

hedbergLemma (A: U) (a b:A) (f : (x : A) -> Path A a x -> Path A a x) (p : Path A a b) :
            Square A a a a b (refl A a) p (f a (refl A a)) (f b p) = undefined
            
hedbergStable (A : U) (a b : A) (h : (x : A) -> stable (Path A a x))
        (p q : Path A a b) : Path (Path A a b) p q =
 <j i> hcom 0->1 A  [ (j = 0) -> rem2 @ i
                      , (j = 1) -> rem3 @ i
                      , (i = 0) -> r
                      , (i = 1) -> rem4 @ j] a
 where 
   ra : Path A a a = <_> a 
   rem1 (x : A) : exConst (Path A a x) = stableConst (Path A a x) (h x)
   f (x : A) : Path A a x -> Path A a x  = (rem1 x).1
   fIsConst (x : A) : const (Path A a x) (f x) = (rem1 x).2
   rem4 : Square A a a b b ra (refl A b) (f b p) (f b q)  = fIsConst b p q
   r : Path A a a = f a ra
   rem2 : Square A a a a b ra p r (f b p) = hedbergLemma A a b f p
   rem3 : Square A a a a b ra q r (f b q) = hedbergLemma A a b f q

hedbergS (A:U) (h : (a x:A) -> stable (Path A a x)) : set A =
 \(a b : A) -> hedbergStable A a b (h a)

hedberg (A : U) (h : discrete A) : set A =
 \(a b : A) -> hedbergStable A a b (\(b : A) -> decStable (Path A a b) (h a b))

